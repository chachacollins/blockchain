const std = @import("std");
const zap = @import("zap");
const block = @import("blockchain.zig");
const allocator = std.heap.page_allocator;

fn on_request(r: zap.Request) void {
    if (r.methodAsEnum() == .GET) {
        if (r.path) |the_path| {
            std.debug.print("PATH: {s}\n", .{the_path});
            const blockchain = block.BlockChain.items;
            defer block.BlockChain.deinit();
            var buffer: [1024]u8 = undefined;
            var json_to_send: []const u8 = undefined;
            if (zap.stringifyBuf(&buffer, blockchain, .{})) |json| {
                json_to_send = json;
            } else {
                json_to_send = "null";
            }
            std.debug.print("<< json: {s}\n", .{json_to_send});
            r.setContentType(.JSON) catch return;
            r.setContentTypeFromFilename("test.json") catch return;
            r.sendBody(json_to_send) catch return;
        }
    }
    if (r.methodAsEnum() == .POST) {
        if (r.path) |the_path| {
            std.debug.print("PATH: {s}\n", .{the_path});
            const parsed = std.json.parseFromSlice(block.Message, allocator, r.body.?, .{});
            defer parsed.deinit();
            const message = parsed.value catch return;
            const newBlock = try block.generateBlock(block.BlockChain.getLast(), message.Coin);
            if (try block.isBlockValid(block.BlockChain.getLast(), newBlock)) {
                const newBlockChain = block.BlockChain.append(newBlock);
                try block.replaceChain(newBlockChain);
            }
            const blockchain = block.BlockChain.items;
            defer block.BlockChain.deinit();
            var buffer: [1024]u8 = undefined;
            var json_to_send: []const u8 = undefined;
            if (zap.stringifyBuf(&buffer, blockchain, .{})) |json| {
                json_to_send = json;
            } else {
                json_to_send = "null";
            }
            std.debug.print("<< json: {s}\n", .{json_to_send});
            r.setContentType(.JSON) catch return;
            r.setContentTypeFromFilename("test.json") catch return;
            r.sendBody(json_to_send) catch return;
        }
    }
}

pub fn main() !void {
    const emptyHash: [32]u8 = [_]u8{0} ** 32;
    const time = std.time.timestamp();
    const genesisBlock = block.Block{
        //please zls formatter don't be stupid
        .Index = 0,
        .Coin = 0,
        .TimeStamp = try block.numToString(time),
        .Hash = emptyHash,
        .PrevHash = emptyHash,
    };
    try block.BlockChain.append(genesisBlock);

    var listener = zap.HttpListener.init(.{
        .port = 6969,
        .on_request = on_request,
        .log = true,
    });
    try listener.listen();

    std.debug.print("Listening on 0.0.0.0:6969\n", .{});

    // start worker threads
    zap.start(.{
        .threads = 2,
        .workers = 2,
    });
}
